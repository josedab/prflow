import type { DocAgentInput, AgentContext, DocUpdateResult, DocUpdate, DocType, SemanticChange } from '@prflow/core';
import { BaseAgent, callLLM, buildSystemPrompt, type LLMMessage } from './base.js';
import { getFileExtension, getLanguageFromExtension } from '@prflow/core';
import { logger } from '../lib/logger.js';

export class DocumentationAgent extends BaseAgent<DocAgentInput, DocUpdateResult> {
  readonly name = 'doc';
  readonly description = 'Generates and updates documentation based on code changes';
  
  private useLLM = process.env.ENABLE_LLM_DOCS !== 'false';

  async execute(input: DocAgentInput, context: AgentContext) {
    const { result, latencyMs } = await this.measureExecution(async () => {
      return this.generateDocs(input, context);
    });

    if (!result) {
      return this.createErrorResult('Documentation generation failed', latencyMs);
    }

    return this.createSuccessResult(result, latencyMs);
  }

  private async generateDocs(input: DocAgentInput, _context: AgentContext): Promise<DocUpdateResult> {
    const { pr, diff, analysis } = input;
    const updates: DocUpdate[] = [];
    let changelogEntry: string | undefined;

    // Check for functions needing JSDoc
    for (const file of diff.files) {
      if (!file.patch) continue;
      if (!this.isDocumentableFile(file.filename)) continue;

      // Try LLM-based documentation generation
      if (this.useLLM) {
        try {
          const llmDocs = await this.generateDocsWithLLM(file.filename, file.patch, analysis.semanticChanges);
          updates.push(...llmDocs);
        } catch (error) {
          logger.warn({ error, file: file.filename }, 'LLM doc generation failed, using template-based');
          const jsdocUpdates = this.generateJSDocUpdates(file.filename, file.patch, analysis.semanticChanges);
          updates.push(...jsdocUpdates);
        }
      } else {
        const jsdocUpdates = this.generateJSDocUpdates(file.filename, file.patch, analysis.semanticChanges);
        updates.push(...jsdocUpdates);
      }
    }

    // Check if README needs updating
    const readmeUpdate = await this.checkReadmeNeeds(pr, diff, analysis);
    if (readmeUpdate) {
      updates.push(readmeUpdate);
    }

    // Generate changelog entry for significant PRs
    if (this.shouldGenerateChangelog(analysis)) {
      changelogEntry = await this.generateChangelogEntry(pr, analysis);
      updates.push({
        docType: 'changelog',
        file: 'CHANGELOG.md',
        content: changelogEntry,
        reason: 'New features or changes that should be documented',
      });
    }

    // Check for API documentation needs
    const apiDocs = await this.checkApiDocNeeds(diff, analysis);
    updates.push(...apiDocs);

    return { updates, changelogEntry };
  }

  private async generateDocsWithLLM(
    filename: string,
    patch: string,
    _semanticChanges: SemanticChange[]
  ): Promise<DocUpdate[]> {
    const language = getLanguageFromExtension(getFileExtension(filename));
    
    const systemPrompt = buildSystemPrompt('documentation', `
Language: ${language}
File: ${filename}
`);

    const userPrompt = `Generate documentation for the following code changes.

## File: ${filename}

## Code Changes:
\`\`\`${language}
${patch}
\`\`\`

For each new or modified function/method, generate appropriate documentation:
- For TypeScript/JavaScript: JSDoc comments
- For Python: Docstrings
- For Go: Doc comments

Focus on:
1. Clear description of what the function does
2. Parameter descriptions with types
3. Return value description
4. Any important notes or warnings

Respond with a JSON array of documentation updates:
[
  {
    "type": "jsdoc",
    "functionName": "string",
    "line": number,
    "content": "string (the actual doc comment)"
  }
]

If no documentation is needed, return an empty array [].
Respond with ONLY the JSON array.`;

    const messages: LLMMessage[] = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt },
    ];

    const response = await callLLM(messages, {
      temperature: 0.3,
      maxTokens: 2000,
    });

    try {
      const content = response.content.trim();
      const jsonStr = content.startsWith('[') ? content :
                      content.match(/```(?:json)?\s*([\s\S]*?)```/)?.[1] || content;
      
      const llmDocs: Array<{ type: string; functionName: string; line: number; content: string }> = JSON.parse(jsonStr);
      
      return llmDocs.map((doc) => ({
        docType: 'jsdoc' as DocType,
        file: filename,
        content: doc.content,
        reason: `Function '${doc.functionName}' documentation generated by AI`,
        startLine: doc.line,
      }));
    } catch (error) {
      logger.warn({ error }, 'Failed to parse LLM documentation response');
      return [];
    }
  }

  private isDocumentableFile(filename: string): boolean {
    const documentableExtensions = ['ts', 'tsx', 'js', 'jsx', 'py', 'go', 'java'];
    const ext = getFileExtension(filename);
    return documentableExtensions.includes(ext);
  }

  private generateJSDocUpdates(
    filename: string,
    patch: string,
    _semanticChanges: SemanticChange[]
  ): DocUpdate[] {
    const updates: DocUpdate[] = [];
    const language = getLanguageFromExtension(getFileExtension(filename));
    const lines = patch.split('\n');

    // Find functions without documentation
    let currentLine = 0;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // Track line numbers from hunk headers
      const hunkMatch = line.match(/^@@ -\d+(?:,\d+)? \+(\d+)/);
      if (hunkMatch) {
        currentLine = parseInt(hunkMatch[1], 10) - 1;
        continue;
      }

      if (!line.startsWith('+') || line.startsWith('+++')) continue;
      currentLine++;

      const code = line.substring(1);

      // Check for function definitions
      const funcMatch = this.matchFunctionDefinition(code, language);
      if (funcMatch) {
        // Check if previous lines have JSDoc
        const prevLines = lines.slice(Math.max(0, i - 5), i);
        const hasDoc = prevLines.some((l) => 
          l.includes('/**') || l.includes('"""') || l.includes("'''")
        );

        if (!hasDoc) {
          const jsdoc = this.generateJSDoc(funcMatch.name, funcMatch.params, language);
          updates.push({
            docType: 'jsdoc',
            file: filename,
            content: jsdoc,
            reason: `Function '${funcMatch.name}' is missing documentation`,
            startLine: currentLine,
          });
        }
      }
    }

    return updates;
  }

  private matchFunctionDefinition(code: string, language: string): { name: string; params: string[] } | null {
    const patterns: Record<string, RegExp[]> = {
      typescript: [
        /(?:export\s+)?(?:async\s+)?function\s+(\w+)\s*\(([^)]*)\)/,
        /(?:export\s+)?const\s+(\w+)\s*=\s*(?:async\s+)?\(([^)]*)\)/,
        /(?:public|private|protected)\s+(?:async\s+)?(\w+)\s*\(([^)]*)\)/,
      ],
      javascript: [
        /(?:export\s+)?(?:async\s+)?function\s+(\w+)\s*\(([^)]*)\)/,
        /(?:export\s+)?const\s+(\w+)\s*=\s*(?:async\s+)?\(([^)]*)\)/,
      ],
      python: [
        /def\s+(\w+)\s*\(([^)]*)\)/,
        /async\s+def\s+(\w+)\s*\(([^)]*)\)/,
      ],
      go: [
        /func\s+(\w+)\s*\(([^)]*)\)/,
      ],
    };

    const langPatterns = patterns[language] || patterns.typescript;

    for (const pattern of langPatterns) {
      const match = code.match(pattern);
      if (match) {
        const params = match[2] 
          ? match[2].split(',').map((p) => p.trim().split(/[:\s]/)[0]).filter(Boolean)
          : [];
        return { name: match[1], params };
      }
    }

    return null;
  }

  private generateJSDoc(funcName: string, params: string[], language: string): string {
    if (language === 'python') {
      let doc = `    """${funcName}\n\n`;
      doc += `    TODO: Add description\n\n`;
      if (params.length > 0 && params[0] !== 'self') {
        doc += `    Args:\n`;
        for (const param of params.filter((p) => p !== 'self')) {
          doc += `        ${param}: TODO\n`;
        }
      }
      doc += `\n    Returns:\n        TODO\n    """\n`;
      return doc;
    }

    // JSDoc style for JS/TS
    let doc = `/**\n`;
    doc += ` * ${funcName}\n`;
    doc += ` * TODO: Add description\n`;
    doc += ` *\n`;
    for (const param of params) {
      doc += ` * @param ${param} - TODO\n`;
    }
    doc += ` * @returns TODO\n`;
    doc += ` */\n`;
    return doc;
  }

  private async checkReadmeNeeds(
    pr: { title: string; body: string | null },
    diff: { files: { filename: string }[] },
    analysis: { type: string; semanticChanges: SemanticChange[] }
  ): Promise<DocUpdate | null> {
    // Check if this is a feature PR that might need README updates
    if (analysis.type !== 'feature') return null;

    // Check for significant changes
    const hasNewApis = analysis.semanticChanges.some((c) => c.type === 'new_api');
    const hasNewDeps = analysis.semanticChanges.some((c) => c.type === 'dependency_added');
    const hasConfigChanges = analysis.semanticChanges.some((c) => c.type === 'config_change');

    if (!hasNewApis && !hasNewDeps && !hasConfigChanges) return null;

    // Try LLM-based README suggestion
    if (this.useLLM) {
      try {
        const content = await this.generateReadmeWithLLM(pr, analysis);
        return {
          docType: 'readme',
          file: 'README.md',
          content,
          reason: 'Feature changes may require README updates',
        };
      } catch (error) {
        logger.warn({ error }, 'LLM README generation failed, using template');
      }
    }

    let content = `## ${pr.title}\n\n`;
    
    if (hasNewApis) {
      content += `### New API Endpoints\n\nTODO: Document new endpoints\n\n`;
    }
    
    if (hasNewDeps) {
      content += `### Dependencies\n\nNew dependencies have been added. Update installation instructions if needed.\n\n`;
    }
    
    if (hasConfigChanges) {
      content += `### Configuration\n\nConfiguration options have changed. Update the configuration section.\n\n`;
    }

    return {
      docType: 'readme',
      file: 'README.md',
      content,
      reason: 'Feature changes may require README updates',
    };
  }

  private async generateReadmeWithLLM(
    pr: { title: string; body: string | null },
    analysis: { type: string; semanticChanges: SemanticChange[] }
  ): Promise<string> {
    const systemPrompt = buildSystemPrompt('documentation', 'README file update');

    const changesDescription = analysis.semanticChanges
      .map((c) => `- ${c.type}: ${c.name} (${c.file})`)
      .join('\n');

    const userPrompt = `Generate a README section for the following PR changes:

## PR Title: ${pr.title}

## PR Description:
${pr.body || 'No description provided'}

## Semantic Changes:
${changesDescription}

Generate a well-formatted markdown section that:
1. Explains the new features/changes
2. Includes usage examples if applicable
3. Documents any new configuration options
4. Is concise but informative

Respond with ONLY the markdown content.`;

    const messages: LLMMessage[] = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt },
    ];

    const response = await callLLM(messages, {
      temperature: 0.5,
      maxTokens: 1500,
    });

    return response.content.trim();
  }

  private shouldGenerateChangelog(analysis: { type: string; riskLevel: string }): boolean {
    // Generate changelog for features, significant bugfixes, and breaking changes
    return (
      analysis.type === 'feature' ||
      (analysis.type === 'bugfix' && analysis.riskLevel !== 'low') ||
      analysis.riskLevel === 'high' ||
      analysis.riskLevel === 'critical'
    );
  }

  private async generateChangelogEntry(
    pr: { number: number; title: string },
    analysis: { type: string; semanticChanges: SemanticChange[] }
  ): Promise<string> {
    // Try LLM-based changelog generation
    if (this.useLLM) {
      try {
        return await this.generateChangelogWithLLM(pr, analysis);
      } catch (error) {
        logger.warn({ error }, 'LLM changelog generation failed, using template');
      }
    }

    const category = this.getChangelogCategory(analysis.type);
    
    let entry = `## [Unreleased]\n\n`;
    entry += `### ${category}\n\n`;
    entry += `- ${pr.title} (#${pr.number})\n`;

    // Add details about specific changes
    const significantChanges = analysis.semanticChanges.filter(
      (c) => c.type === 'new_api' || c.type === 'new_function' || c.type === 'dependency_added'
    );

    if (significantChanges.length > 0) {
      for (const change of significantChanges.slice(0, 3)) {
        entry += `  - ${this.formatChangeForChangelog(change)}\n`;
      }
    }

    return entry;
  }

  private async generateChangelogWithLLM(
    pr: { number: number; title: string },
    analysis: { type: string; semanticChanges: SemanticChange[] }
  ): Promise<string> {
    const systemPrompt = buildSystemPrompt('documentation', 'CHANGELOG entry generation');

    const changesDescription = analysis.semanticChanges
      .map((c) => `- ${c.type}: ${c.name}`)
      .join('\n');

    const userPrompt = `Generate a CHANGELOG entry following the Keep a Changelog format.

## PR: ${pr.title} (#${pr.number})
## PR Type: ${analysis.type}

## Changes:
${changesDescription}

Generate a well-formatted CHANGELOG entry that:
1. Uses the appropriate category (Added, Changed, Fixed, Deprecated, Removed, Security)
2. Is concise but informative
3. Follows semantic versioning conventions

Respond with ONLY the CHANGELOG entry content.`;

    const messages: LLMMessage[] = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt },
    ];

    const response = await callLLM(messages, {
      temperature: 0.4,
      maxTokens: 500,
    });

    return response.content.trim();
  }

  private getChangelogCategory(prType: string): string {
    const categories: Record<string, string> = {
      feature: 'Added',
      bugfix: 'Fixed',
      refactor: 'Changed',
      deps: 'Dependencies',
      docs: 'Documentation',
      test: 'Testing',
      chore: 'Maintenance',
    };
    return categories[prType] || 'Changed';
  }

  private formatChangeForChangelog(change: SemanticChange): string {
    switch (change.type) {
      case 'new_api':
        return `New API: ${change.name}`;
      case 'new_function':
        return `New function: ${change.name}`;
      case 'dependency_added':
        return `Added dependency: ${change.name}`;
      default:
        return `${change.type}: ${change.name}`;
    }
  }

  private async checkApiDocNeeds(
    diff: { files: { filename: string; patch?: string }[] },
    analysis: { semanticChanges: SemanticChange[] }
  ): Promise<DocUpdate[]> {
    const updates: DocUpdate[] = [];

    // Find API-related files
    const apiChanges = analysis.semanticChanges.filter(
      (c) => c.type === 'new_api' || c.type === 'modified_api'
    );

    for (const change of apiChanges) {
      const file = diff.files.find((f) => f.filename === change.file);
      let content: string;

      if (this.useLLM && file?.patch) {
        try {
          content = await this.generateApiDocWithLLM(change, file.patch);
        } catch (error) {
          logger.warn({ error }, 'LLM API doc generation failed, using template');
          content = this.generateApiDocTemplate(change);
        }
      } else {
        content = this.generateApiDocTemplate(change);
      }

      updates.push({
        docType: 'api_docs',
        file: change.file.replace(/\.(ts|js)$/, '.md'),
        content,
        reason: `API ${change.type === 'new_api' ? 'added' : 'modified'}: ${change.name}`,
      });
    }

    return updates;
  }

  private async generateApiDocWithLLM(change: SemanticChange, patch: string): Promise<string> {
    const systemPrompt = buildSystemPrompt('documentation', 'API documentation');

    const userPrompt = `Generate comprehensive API documentation for the following endpoint.

## API: ${change.name}
## File: ${change.file}

## Code:
\`\`\`
${patch}
\`\`\`

Generate documentation that includes:
1. Endpoint URL and method
2. Request parameters/body with types
3. Response format with examples
4. Error responses
5. Usage example with curl

Use markdown format with code blocks. Respond with ONLY the documentation.`;

    const messages: LLMMessage[] = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt },
    ];

    const response = await callLLM(messages, {
      temperature: 0.4,
      maxTokens: 2000,
    });

    return response.content.trim();
  }

  private generateApiDocTemplate(change: SemanticChange): string {
    let doc = `# API: ${change.name}\n\n`;
    doc += `## Endpoint\n\n`;
    doc += `\`\`\`\n`;
    doc += `TODO: Add endpoint details\n`;
    doc += `\`\`\`\n\n`;
    doc += `## Request\n\n`;
    doc += `TODO: Document request format\n\n`;
    doc += `## Response\n\n`;
    doc += `TODO: Document response format\n\n`;
    doc += `## Example\n\n`;
    doc += `\`\`\`bash\n`;
    doc += `curl -X GET /api/...\n`;
    doc += `\`\`\`\n`;
    return doc;
  }
}
